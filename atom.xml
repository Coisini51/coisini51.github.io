<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>july的博客</title>
  
  
  <link href="https://coisini51.github.io/atom.xml" rel="self"/>
  
  <link href="https://coisini51.github.io/"/>
  <updated>2025-08-14T10:45:48.177Z</updated>
  <id>https://coisini51.github.io/</id>
  
  <author>
    <name>july</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello hexo!</title>
    <link href="https://coisini51.github.io/2025/08/15/hello%20Hexo/"/>
    <id>https://coisini51.github.io/2025/08/15/hello%20Hexo/</id>
    <published>2025-08-15T01:18:00.340Z</published>
    <updated>2025-08-14T10:45:48.177Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/">Hexo</a>的入门使用。<br>这是我的第一篇文章。 如果需要更多信息，可以去查看<a href="https://hexo.io/docs/">官方文档</a>要是在使用Hexo时遇到问题，可以去<a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a>里找答案，也可以去<a href="https://github.com/hexojs/hexo/issues">GitHub</a>上提问。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>默认情况下，我新建的文章会保存在 source&#x2F;_posts 文件夹里。</p><h3 id="快速清除缓存生成静态文件并部署"><a href="#快速清除缓存生成静态文件并部署" class="headerlink" title="快速清除缓存生成静态文件并部署"></a>快速清除缓存生成静态文件并部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>上传新文章可直接复制使用</p><span id="more"></span><h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>首先，我得安装服务器插件：npm install hexo-server –save。现已安装好。然后，我就可以运行服务器了。 服务器默认会跑在 <a href="http://localhost:4000。">http://localhost:4000。</a> 如果想改端口（比如改成 5000），我可以用 hexo server -p 5000。服务器会自动监测文件变化。<br>更多信息： <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>这个命令会帮我的网站生成静态文件。我要是加上 –watch 选项，它就能监测文件变化并自动重新生成了，<br>比如 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate --watch</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>首先，我得装个部署插件（比如用 Git 部署的话，就装 npm install hexo-deployer-git –save）。现已安装好。<br>然后在 _config.yml 里配置好部署信息（指定 type、repo 这些）。我还可以生成文件后直接部署，用 hexo generate –deploy 或者 hexo deploy –generate 就行。<br>更多信息: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;的入门使用。&lt;br&gt;这是我的第一篇文章。 如果需要更多信息，可以去查看&lt;a href=&quot;https://hexo.io/docs/&quot;&gt;官方文档&lt;/a&gt;要是在使用Hexo时遇到问题，可以去&lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt;里找答案，也可以去&lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;上提问。&lt;/p&gt;
&lt;h2 id=&quot;快速开始&quot;&gt;&lt;a href=&quot;#快速开始&quot; class=&quot;headerlink&quot; title=&quot;快速开始&quot;&gt;&lt;/a&gt;快速开始&lt;/h2&gt;&lt;h3 id=&quot;创建新文章&quot;&gt;&lt;a href=&quot;#创建新文章&quot; class=&quot;headerlink&quot; title=&quot;创建新文章&quot;&gt;&lt;/a&gt;创建新文章&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo new &lt;span class=&quot;string&quot;&gt;&amp;quot;My New Post&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;默认情况下，我新建的文章会保存在 source&amp;#x2F;_posts 文件夹里。&lt;/p&gt;
&lt;h3 id=&quot;快速清除缓存生成静态文件并部署&quot;&gt;&lt;a href=&quot;#快速清除缓存生成静态文件并部署&quot; class=&quot;headerlink&quot; title=&quot;快速清除缓存生成静态文件并部署&quot;&gt;&lt;/a&gt;快速清除缓存生成静态文件并部署&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo clean &amp;amp;&amp;amp; hexo g &amp;amp;&amp;amp; hexo d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上传新文章可直接复制使用&lt;/p&gt;</summary>
    
    
    
    <category term="技术工具" scheme="https://coisini51.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="https://coisini51.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="hexo" scheme="https://coisini51.github.io/tags/hexo/"/>
    
    <category term="Markdown" scheme="https://coisini51.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>缓存问题</title>
    <link href="https://coisini51.github.io/2025/08/14/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>https://coisini51.github.io/2025/08/14/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</id>
    <published>2025-08-14T10:50:28.000Z</published>
    <updated>2025-08-14T11:16:07.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。如果大量的请求同时过来访问这种不存在的数据，数据库很可能无法承载这样的并发。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p>思路分析：当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，数据库中也没有数据，那我们就把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据。</p><span id="more"></span><h4 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h4><p>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，假设布隆过滤器判断这个数据不存在，则直接返回。</p><table><thead><tr><th></th><th>缓存空对象</th><th>布隆过滤</th><th></th></tr></thead><tbody><tr><td>优点</td><td>实现简单，维护方便</td><td>内存占用较少，没有多余key</td><td></td></tr><tr><td>缺点</td><td>额外的内存消耗；可能造成短期的不一致</td><td>实现复杂；存在误判可能</td><td></td></tr></tbody></table><blockquote><p>误判原因：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突<br>![[Pasted image 20250814180802.png]]</p></blockquote><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>增强id的复杂度，避免被猜测id规律；</li><li>做好数据的基础格式校验；</li><li>加强用户权限校验；</li><li>做好热点参数的限流</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>假设线程1查缓存未命中，打算查库并更新缓存。若此时线程2、3、4也来访问，都会因缓存未命中而同时查库，给数据库带来压力。<br>用tryLock加双重检查可解决：</p><ul><li>线程1没命中缓存，拿到锁后去查库、更新缓存。</li><li>线程2、3、4没拿到锁，会等待。</li><li>线程1释放锁后，线程2等拿到锁，再次检查缓存（此时已被线程1更新），直接从缓存获取数据，无需再查库。<br>这样既避免了数据库压力过大，又减少了串行等待对性能的影响。</li></ul><h4 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h4><p>把过期时间存在 Redis 的 value 里。</p><ul><li>线程 1 查缓存，发现 value 里的时间已过期，就获取互斥锁，同时开一个新线程去数据库查数据、更新缓存，自己直接返回旧数据。</li><li>线程 2、3 等过来时，因拿不到锁，也直接返回旧数据。</li><li>直到新线程更新完缓存，后续线程才能拿到新数据。<br>这样既避免了 key 过期后瞬间大量请求击垮数据库，又不用让线程等待重构，还能通过逻辑过期清理旧数据，减少内存占用。<br><strong>进行对比</strong><br><strong>互斥锁</strong>：由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响<br><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦。<br>![[Pasted image 20250814183700.png]]</li></ul><h4 id="其他方法："><a href="#其他方法：" class="headerlink" title="其他方法："></a>其他方法：</h4><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。思路和缓存雪崩一样。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;缓存穿透&quot;&gt;&lt;a href=&quot;#缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;缓存穿透&quot;&gt;&lt;/a&gt;缓存穿透&lt;/h2&gt;&lt;p&gt;缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。如果大量的请求同时过来访问这种不存在的数据，数据库很可能无法承载这样的并发。&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h3&gt;&lt;h4 id=&quot;缓存空对象&quot;&gt;&lt;a href=&quot;#缓存空对象&quot; class=&quot;headerlink&quot; title=&quot;缓存空对象&quot;&gt;&lt;/a&gt;缓存空对象&lt;/h4&gt;&lt;p&gt;思路分析：当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，数据库中也没有数据，那我们就把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://coisini51.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="缓存" scheme="https://coisini51.github.io/categories/%E5%90%8E%E7%AB%AF/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="redis" scheme="https://coisini51.github.io/tags/redis/"/>
    
    <category term="缓存" scheme="https://coisini51.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
